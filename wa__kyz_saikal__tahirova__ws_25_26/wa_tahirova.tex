\documentclass[a4paper,12pt]{article}

% --- Sprach- und Kodierungseinstellungen ---
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[ngerman]{babel}

% --- Typografie ---
\usepackage{lmodern}
\usepackage{microtype}
\usepackage{csquotes} % Korrekte deutsche Anführungszeichen
\usepackage{setspace}
\onehalfspacing

% --- Seitenlayout ---
\usepackage[left=2.5cm,right=2.5cm,top=3cm,bottom=3cm]{geometry}
\usepackage{indentfirst}
\setlength{\parindent}{1.25em} % Отступ первой строки
\setlength{\parskip}{0pt}      % Без дополнительного вертикального расстояния

% --- Grafiken ---
\usepackage{graphicx}
\graphicspath{{./img/}} 

% --- Farben, Links, URLs ---
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{url}
\urlstyle{same}
\hypersetup{
    pdftitle={Nutzung von Sprachmodellen zur Verbesserung von Bezeichnern in Java-Programmen},
    pdfauthor={Kyz Saikal Tahirova},
    pdfsubject={Wissenschaftliche Arbeit},
    pdfkeywords={Sprachmodelle, Java, Bezeichner, Programmierung},
    colorlinks=true,
    linkcolor=black,
    citecolor=black,
    urlcolor=blue,
    pdfpagemode=UseOutlines
}

\usepackage{enumitem}
\setlist{itemsep=3pt, topsep=3pt, parsep=0pt, partopsep=0pt}

% --- Mathe und Tabellen ---
\usepackage{amsmath,amssymb,booktabs}

% --- Quellcode ---
\usepackage{listings}
\lstdefinestyle{javaStyle}{
    language=Java,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue!70!black}\bfseries,
    stringstyle=\color{red!60!black},
    commentstyle=\color{gray},
    numbers=left,
    numberstyle=\tiny\color{gray},
    stepnumber=1,
    showstringspaces=false,
    tabsize=4,
    breaklines=true,
    frame=single,
    inputencoding=utf8,
    extendedchars=true,
    literate={ä}{{\"a}}1 {ö}{{\"o}}1 {ü}{{\"u}}1 {ß}{{\ss}}1
}
\lstset{style=javaStyle}

% --- Verzeichnisse ---
\usepackage[nottoc,notlof,notlot]{tocbibind}

% ===============================
%           Dokument
% ===============================
\begin{document}

% --- Titelseite ---
\begin{titlepage}
    \centering
    \includegraphics[width=0.7\textwidth]{WHZ-Logo.jpg}\\[1cm]

    {\Large\textbf{Westsächsische Hochschule Zwickau}}\\[1ex]
    {\large Fakultät für Physikalische Technik und Informatik}\\[4cm]

    {\LARGE\textbf{Wissenschaftliche Arbeit}}\\[1cm]

    {\Large\textbf{Thema:}}\\[0.5cm]
    {\Large Nutzung von Sprachmodellen zur Verbesserung von Bezeichnern in Java-Programmen}\\[3cm]

    \begin{tabular}{rl}
        Vorgelegt von: & Kyz Saikal Tahirova \\
        Matrikel-Nr.:  & 66110                 \\
        Studiengang:   & Informatik            \\
        Betreuer:      & Prof.\ Dr.\ Laue      \\
        Abgabetermin:  & xx.xx.2025            \\
    \end{tabular}
\end{titlepage}

\setcounter{page}{2}

\clearpage

% --- Inhaltsverzeichnis ---
\tableofcontents
\clearpage

% --- Hauptteil ---
\section*{Kapitel 1}
\section{Einleitung}

Sprachmodelle werden in der Softwareentwicklung immer häufiger eingesetzt, um Entwickler bei Analyse- und Review-Aufgaben zu unterstützen. Ein wichtiger Anwendungsbereich ist die Bewertung von Bezeichnern im Quellcode. Klare und verständliche Namen vereinfachen die Wartung, während verschwommene Bezeichner zu Fehlern und erhöhtem Aufwand führen \cite{identifiernamesinfluencecodequality}.

Diese Arbeit untersucht die Zuverlässigkeit moderner Sprachmodelle bei der Einschätzung von Java-Bezeichnern. Bewertet werden Verständlichkeit, semantische Angemessenheit, Einhaltung etablierter Namenskonventionen \cite{oracle} sowie die Erkennung linguistischer Anti-Muster \cite{arnaoudova2014,newfamlas}. Unter linguistischen Anti-Mustern versteht man systematische sprachliche Probleme in Bezeichnern, die Klarheit und Lesbarkeit beeinträchtigen.

Ziel der Untersuchung ist es zu prüfen, ob Sprachmodelle hilfreiche und konsistente Hinweise zur Verbesserung von Bezeichnern liefern können. Hierfür werden mehrere Prompt-Varianten entwickelt und schrittweise verfeinert. Die Analyse erfolgt anhand von Java-Beispielen mit sowohl problematischen als auch korrekten Bezeichnern, um die Erkennung tatsächlicher Verstöße und das Auftreten unbegründeter Warnungen („False Positives“) zu bewerten. Frühere Arbeiten zeigen bereits, dass LLM-generierter Code zu semantischen Fehlbenennungen und strukturellen Qualitätsproblemen neigt \cite{llmsmells2025,llmmethodnames2025,aitomaticprogramming}.

Die zentrale Forschungsfrage lautet:
\begin{quote}
Wie zuverlässig können Sprachmodelle Java-Bezeichner hinsichtlich Verständlichkeit, Bedeutung, Konventionen und linguistischer Anti-Muster bewerten?
\end{quote}

Die Arbeit ist in mehrere Kapitel gegliedert:

\begin{enumerate}
    \item \textbf{Kapitel 1 (Einleitung).} Vorstellung des Themas, Zielsetzung, Relevanz von Sprachmodellen in der Softwareentwicklung sowie die Forschungsfrage.
    \item \textbf{Kapitel 2 (Theoretische Hintergrund).} Überblick über Java-Bezeichner, Namenskonventionen und linguistische Anti-Muster.
    \item \textbf{Kapitel 3 (Methodik und Durchführung).} Aufbau der Untersuchung, Entwicklung der Prompt-Varianten sowie Beschreibung der verwendeten Java-Beispiele. \textit{Eine automatische Pipeline wird nur theoretisch erwähnt.}  
    \item \textbf{Kapitel 4 (Evaluation).} Auswertung der Ergebnisse und systematische Bewertung der Antworten der Sprachmodelle. 
    \item \textbf{Kapitel 5 (Diskussion und Schluss).} Grenzen der Methode, Verbesserungsideen, Ausblick auf weitere Forschung.
    
\end{enumerate}

Hinweis: In dieser ersten Version der Arbeit wird der automatische Pipeline-Ansatz nur theoretisch erläutert, da die Umsetzung zum jetzigen Zeitpunkt noch nicht erfolgt ist. In einer späteren Version könnte diese Funktion ergänzt werden, um den gesamten Prozess der Bezeichnerverbesserung automatisch abzubilden.


\newpage
\section*{Kapitel 2}
\section{Theoretische Hintergrund}
\subsection{Java-Bezeichner}

Java-Bezeichner sind die Namen von Variablen, Methoden, Klassen, Schnittstellen, Konstanten und Paketen. Sie sollen die Funktion und den Zweck des Codes verständlich machen. Gute Bezeichner sind selbsterklärend, konsistent und folgen klaren Regeln \cite{oracle}. Sie dürfen nicht mit einer Ziffer beginnen und keine reservierten Wörter wiederholen. In der Praxis orientieren sich gute Namen an ihrer Funktion im Programm und an allgemein anerkannten Konventionen.

\subsection{Namenskonventionen in Java}

Java verwendet für Bezeichner verschiedene Schreibweisen, die hauptsächlich auf CamelCase basieren. Dabei gilt:

\begin{itemize}
    \item {Klassen und Schnittstellen.} Bezeichner für Klassen und Schnittstellen werden als Nominalphrasen formuliert. Jeder Wortanfang steht groß, z.B. \texttt{Student}, \texttt{EnrolledStudents}. Abkürzungen und Akronyme sollten vermieden werden.
    \item {Methoden.} Namen sind Verben, beginnen mit einem Kleinbuchstaben, innere Wortanfänge werden großgeschrieben, z.B. \texttt{calculateSum()}, \texttt{main()}. 
    \item {Variablen.} Namen sollten kurz, aber aussagekräftig sein. Keine Unterstriche oder Dollarzeichen am Anfang. Ein-Zeichen-Variablen nur temporär (z.B. \texttt{i, j, k}). Beispiel: \texttt{totalScore}, \texttt{marks}.
    \item {Konstanten.} Alle Buchstaben groß, Wörter durch Unterstriche getrennt, z.B. \texttt{MAX\_SIZE}, \texttt{PI\_VALUE}.
    \item {Pakete.} Alles klein, oft in Anlehnung an Top-Level-Domains wie \texttt{com}, \texttt{org}. Beispiel: \texttt{java.util.Scanner}.
\end{itemize}

Ein Name soll beschreiben, was ein Element speichert oder ausführt. Unklare Begriffe wie \texttt{tmp}, \texttt{data} oder \texttt{handle} lassen zu viel Interpretationsspielraum und führen schnell zu Missverständnissen.

Die konsequente Anwendung dieser Regeln erhöht die Verständlichkeit und Wartbarkeit von Code, insbesondere in größeren Projekten.

\subsection{Linguistische Anti-Muster}

\textit{Linguistische Anti-Muster (LA)} beschreiben wiederkehrende schlechte Praktiken in der Benennung, Dokumentation und Implementierung von Softwareelementen. Sie stellen also sprachliche Widersprüche oder Inkonsistenzen zwischen Namen, Kommentaren und tatsächlichem Verhalten einer Methode oder eines Attributs dar \cite{arnaoudova2014}.

Im Gegensatz zu klassischen Design-Anti-Patterns, die strukturelle Probleme betreffen, beziehen sich LAs auf die sprachliche Ebene des Codes. Sie zeigen sich zum Beispiel, wenn eine Methode \texttt{get()} heißt, aber keinen Wert zurückgibt, oder eine Methode \texttt{isValid()} keinen booleschen Wert liefert. Ebenso gehören widersprüchliche Kommentare oder unklare Attributnamen zu häufigen Fällen solcher sprachlichen Inkonsistenzen.

Arnaoudova et al. (2013) \cite{newfamlas} analysierten mehrere Open-Source-Projekte wie ArgoUML, Cocoon und Eclipse, um diese Muster systematisch zu erfassen. Dabei wurden typische Kategorien von LAs identifiziert:
\begin{itemize}
    \item Inkonsistenz zwischen Name und Rückgabewert.
    \item Widersprüche zwischen Kommentar und Implementierung
    \item Mehrdeutige oder irreführende Bezeichner.
    \item Verwendung generischer Namen ohne semantischen Bezug.
\end{itemize}

Das Bewusstsein für linguistische Anti-Patterns hilft, Missverständnisse zu vermeiden und die Lesbarkeit, Verständlichkeit und Wartbarkeit von Software nachhaltig zu verbessern.

\subsection{Große Sprachmodelle (LLMs)}

Große Sprachmodelle (LLM), wie GPT oder CodeBERT, haben den Bereich der automatischen Programmierung grundlegend verändert. Sie ermöglichen nicht nur die Code-Erstellung in natürlicher Sprache, sondern führen auch zunehmend Aufgaben wie die Code-Erklärung, die Testgenerierung oder die Fehlerbehebung durch. Daher verlagert sich der Schwerpunkt der Softwareentwicklung von der manuellen Implementierung auf die Zusammenarbeit zwischen Mensch und Modell.

Wie in \textit{Automatic Programming: Large Language Models
and Beyond} \cite{aitomaticprogramming} beschrieben, besteht jedoch weiterhin ein zentrales Problem in der Vertrauenswürdigkeit automatisch generierten Codes. Obwohl LLMs beeindruckende Ergebnisse liefern, bleibt die Frage offen, wann und unter welchen Bedingungen dieser Code als zuverlässig genug gilt, um in reale Projekte integriert zu werden. Neben der Korrektheit spielen auch Aspekte wie Sicherheit, Nachvollziehbarkeit und rechtliche Verantwortung eine Rolle.

In dieser Arbeit wird untersucht, wie zuverlässig Sprachmodelle Java-Bezeichner bewerten können und in welchen Fällen weiterhin menschliches Eingreifen erforderlich ist.

\newpage
\section*{Kapitel 3}
\section{Methodik und Durchführung}

Dieses Kapitel erklärt die Auswahl der Sprachmodelle, die Erstellung von Test-Beispielen nach den Kategorien von Arnaoudova et al. \cite{arnaoudova2014} und die Bewertungskriterien. Das Ziel ist, systematisch zu prüfen, wie gut LLMs linguistische Anti-Patterns in Java-Code erkennen und verbessern können.

\subsection{Auswahl der Sprachmodelle}

Für die Untersuchung wurden drei verschiedene Modelle über HAWKI\footnote{HAWKI dient als Schnittstelle zu OpenAI GPT-4o, Meta LLaMA 3.1 70B Instruct, Alibaba Qwen 2.5 72B Instruct Modellen} abgefragt:

\begin{itemize}
    \item OpenAI GPT-4o,
    \item Meta LLaMA 3.1 70B Instruct,
    \item Alibaba Qwen 2.5 72B Instruct.
\end{itemize}

\subsection{Erstellung der Test-Beispiele}

\subsubsection{Kategorien nach Arnaoudova}

Die linguistischen Anti-Muster nach Arnaoudova et al. \cite{arnaoudova2014} werden in zwei Gruppen unterteilt: methodenbezogene und attributbezogene Muster. Jede Kategorie markiert ein typisches semantisches Problem zwischen Bezeichner und Implementierung. Jedes Muster wurde kurz erklärt und durch ein Beispiel veranschaulicht. Insgesamt wurden 10–15 fehlerhafte Codebeispiele und 5–7 korrekte Beispiele erstellt.

\textbf{Methoden-bezogene Anti-Muster (A, B, C):}

\begin{enumerate}
    \item \textbf{Kategorie A} (\textit{does more than it says}) -- die Methode macht mehr, als der Name verspricht.
    
    \begin{itemize}
        \item \textbf{A1:} Methode mit \texttt{get}, die mehr macht als nur zurückgeben
        \item \textbf{A2:} Methodenname ist Prädikat, aber Rückgabetyp ist nicht Boolean
        \item \textbf{A3:} Methode mit \texttt{set}, die einen Wert zurückgibt
        \item \textbf{A4:} Methodentyp deutet auf mehrere Objekte, Name auf einzelnes
    \end{itemize}
    
    \item \textbf{Kategorie B} (\textit{says more than it does}) -- der Name verspricht mehr, als die Methode tut. 
    
    \begin{itemize}
        \item \textbf{B1:} Kommentar dokumentiert nicht implementierte Bedingung
        \item \textbf{B2:} Validierungsmethode gibt nichts zurück
        \item \textbf{B3:} Name deutet Rückgabe an, aber Rückgabetyp ist \texttt{void}
        \item \textbf{B4:} Name ist Prädikat, aber nichts wird zurückgegeben
    \end{itemize}
    
    \item \textbf{Kategorie C} (\textit{does the opposite}) -- die Methode macht das Gegenteil vom Namen.
    
    \begin{itemize}
        \item \textbf{C1:} Name und Rückgabetyp verwenden Antonyme (Gegensätze)
        \item \textbf{C2:} Kommentar und Signatur verwenden Antonyme
    \end{itemize}
\end{enumerate}

\textbf{Attribut-bezogene Anti-Patterns (D, E, F):}

\begin{enumerate}
    \setcounter{enumi}{3}
    \item \textbf{Kategorie D} (\textit{contains more than it says}) -- das Attribut enthält mehr, als der Name aussagt. 
    
    \begin{itemize}
        \item \textbf{D1:} Attributname deutet Boolean an, aber Typ ist anders
        \item \textbf{D2:} Attributname ist Prädikat, aber Typ ist nicht Boolean
    \end{itemize}
    
    \item \textbf{Kategorie E} (\textit{says more than it contains}) -- der Name sagt mehr, als das Attribut enthält. 
    
    \begin{itemize}
        \item \textbf{E1:} Attributtyp deutet auf einzelnes Objekt, Name auf mehrere
    \end{itemize}
    
    \item \textbf{Kategorie F} (\textit{says the opposite}) -- Name und Inhalt sind gegensätzlich. 
    
    \begin{itemize}
        \item \textbf{F1:} Attributname und Typ verwenden Antonyme
        \item \textbf{F2:} Attributkommentar und Signatur verwenden Antonyme
    \end{itemize}
\end{enumerate}

\subsubsection{Beispiel-Code}

\textbf{Kategorie A1.} Methode mit \texttt{get} macht mehr als zurückgeben:

\begin{lstlisting}
public class UserManager {
    private User currentUser;

    public User getUser() {
        validateSession();   // Nebenwirkung
        return currentUser;
    }
}
\end{lstlisting}


\textbf{Kategorie B3.} Name deutet Rückgabe an, aber \texttt{void}:

\begin{lstlisting}
public class Calculator {
    public void getResult() {
        System.out.println("42");
    }
}
\end{lstlisting}


\textbf{Kategorie C1.} Name und Typ sind Gegensätze:

\begin{lstlisting}
public class Config {
    // Problem: disable() gibt ControlEnableState zuruck
    public ControlEnableState disable() {
        return new ControlEnableState(true);
    }
}
\end{lstlisting}


\textbf{Kategorie D2.} Prädikatname, Typ nicht Boolean:
\begin{lstlisting}
public class Payment {
    private int isActive; // Typ passt nicht zum Prädikat
}
\end{lstlisting}

\textbf{Kategorie E1.} Pluralname bei singular Typ:
\begin{lstlisting}
public class Order {
    private Product products; // Name suggeriert Mehrzahl
}
\end{lstlisting}

\textbf{Kategorie F1.} Name und Typ im Gegensatz:
\begin{lstlisting}[language=Java]
public class Metrics {
    private FailureCounter success; // Erfolg vs. Fehler
}
\end{lstlisting}


\subsection{Prompt-Strategien und Iteration}
Die Prompts wurden iterativ weiterentwickelt (V1 → V2 → V3 → V4). Ziel jeder Iteration war die Verbesserung der Hinweisqualität (automatisches Review) und die Reduzierung von False Positives. V4 enthält zudem eine knappe Definition der linguistischen Anti-Muster, damit Modelle diese Kategorien gezielt erkennen.

\paragraph{V1 (Zero-Shot)}  
\enquote{Analysieren Sie den folgenden Java-Code. Identifizieren Sie mögliche Benennungs- oder Struktur-Anti-Muster.}

\paragraph{V2 (Few-Shot)}  
Positive Beispiele für korrekte Bezeichner werden vorangestellt (z.\,B. \enquote{EnrolledStudents}, \enquote{numberOfValidCreditCards}).

\paragraph{V3 (Regeln)}  
Kurzregeln zu CamelCase, Verben für Methoden, Nominalphrasen für Klassen.

\paragraph{V4 (Erklärung)}  
Kurze Definitionen der Kategorien A–F (linguistische Anti-Muster) werden vorangestellt; die Antwort soll knapp Hinweise für Programmierer liefern, keine automatische Code-Änderung.

\subsection{Durchführung der Tests}

Für jedes der 10–15 fehlerhaften Beispiele und für jedes der 5–7 korrekten Beispiele wurde jede Prompt-Version an alle drei Modelle über HAWKI gesendet. Jede Modellantwort wurde protokolliert und anonymisiert abgespeichert. Der Ablauf:

\begin{enumerate}
    \item Beispiel auswählen und Kategorie zuordnen.
    \item Prompt-Version wählen.
    \item Anfrage an Modell via HAWKI senden.
    \item Ausgabe speichern.
    \item Bewertung durchführen.
\end{enumerate}


\subsection{Bewertungskriterien}

Jedes Kriterium wird mit 1-5 Punkten bewertet.

\begin{enumerate}
    \item \textbf{Anti-Pattern-Erkennung.} Wurde das Problem erkannt?
    
    \item \textbf{Korrekturqualität.} Ist der vorgeschlagene neue Name besser? Löst er das Anti-Pattern?
    
    \item \textbf{Konventions-Konformität.} Folgt der neue Code Java-Standards? 
    
    \item \textbf{Semantische Klarheit.} Sind die neuen Namen verständlich? 
    
    \item \textbf{Konsistenz.} Passt alles zusammen?
\end{enumerate}


\textbf{Spezielle Bewertung nach Kategorien.} Für jede Kategorie A-F wurden spezifische Fragen gestellt:

\begin{itemize}
    \item Kategorie A: Wurde die Extra-Funktionalität dokumentiert oder die Methode umbenannt?
    \item Kategorie B: Wurde der fehlende Rückgabewert hinzugefügt oder der Name korrigiert?
    \item Kategorie C: Wurden die widersprüchlichen Begriffe harmonisiert?
    \item Kategorie D-F: Wurden Attributnamen und Typen in Einklang gebracht?
\end{itemize}


% --- Literaturverzeichnis ---
\clearpage
\begin{thebibliography}{99}

\bibitem{arnaoudova2014}
Arnaoudova, V.; Di Penta, M.; Antoniol, G. (2014):
\textit{Linguistic Anti-Patterns: What They Are and How Developers Perceive Them.}
Empirical Software Engineering.
Verfügbar unter: \url{https://www.veneraarnaoudova.ca/wp-content/uploads/2014/10/2014-EMSE-Arnaodova-et-al-Perception-LAs.pdf},
abgerufen am 14.10.2025.

\bibitem{newfamlas}
European Conference on Software Maintenance and Reengineering (2013):
\textit{A New Family of Software Anti-Patterns: Linguistic Anti-Patterns.}
Konferenzbeitrag CSMR 2013.
Verfügbar unter: \url{https://assets.ptidej.net/Publications/Documents/CSMR13d.doc.pdf},
abgerufen am 15.11.2025.

\bibitem{oracle}
Oracle Corporation:
\textit{Naming Conventions.}
Verfügbar unter: \url{https://www.oracle.com/java/technologies/javase/codeconventions-namingconventions.html},
abgerufen am 14.10.2025.

\bibitem{aitomaticprogramming}
Lyu, M. R.; Rajan, B.; Roychoudhury, A.; Tan, S. H.; Thummalapenta, P.:
\textit{Automatic Programming: Large Language Models and Beyond.}
Verfügbar unter: \url{https://dl.acm.org/doi/pdf/10.1145/3708519},
abgerufen am 15.11.2025.

\bibitem{identifiernamesinfluencecodequality}
Butler, S.; Wermelinger, M.; Yu, Y.; Sharp, H. (2010):
\textit{Exploring the Influence of Identifier Names on Code Quality: An Empirical Study.}
In: Proceedings of the 14th European Conference on Software Maintenance and Reengineering (CSMR), 15--18 March 2010, Madrid, Spain.
Verfügbar unter: \url{https://www.researchgate.net/publication/42799923_Exploring_the_Influence_of_Identifier_Names_on_Code_Quality_An_Empirical_Study},
abgerufen am 26.11.2025.

\bibitem{llmsmells2025}
Ghosh Paul, D.; Zhu, H.; Bayley, I. (2025):
\textit{Investigating the Smells of LLM Generated Code.}
School of Engineering, Computing and Mathematics, Oxford Brookes University, October 2025.
Verfügbar unter: \url{https://www.researchgate.net/publication/396223444_Investigating_The_Smells_of_LLM_Generated_Code},
abgerufen am 26.11.2025.

\bibitem{llmmaintainablereliable2025}
Santa Molison, A.; Moraes, M.; Melo, G.; Santos, F.; Assunção, W. K. G. (2025):
\textit{Is LLM-Generated Code More Maintainable \& Reliable than Human-Written Code?}
Toronto Metropolitan University; Colorado State University; North Carolina State University, July 2025.
Verfügbar unter: \url{https://www.researchgate.net/publication/393853113_Is_LLM-Generated_Code_More_Maintainable_Reliable_than_Human-Written_Code},
abgerufen am 26.11.2025.

\bibitem{llmmethodnames2025}
Akram, W.; Jiang, Y.; Zhang, Y.; Khan, H. A.; Liu, H. (2025):
\textit{LLM-Based Method Name Suggestion with Automatically Generated Context-Rich Prompts.}
Beijing Institute of Technology; Peking University.
Verfügbar unter: \url{https://www.researchgate.net/publication/392855381_LLM-Based_Method_Name_Suggestion_with_Automatically_Generated_Context-Rich_Prompts},
abgerufen am 27.11.2025.

\bibitem{llmdetection2025}
Andrade, R.; Torres, J.; Ortiz-Garcés, I. (2025):
\textit{Enhancing Security in Software Design Patterns and Antipatterns: A Framework for LLM-Based Detection.}
In: Electronics, 14(3) (2025), Artikel Nr. 586.
DOI: \url{https://doi.org/10.3390/electronics14030586}.
Submission received: 16.11.2024; revised: 21.01.2025; accepted: 28.01.2025; published: 01.02.2025.


\end{thebibliography}

\end{document}
